{
    "collab_server" : "",
    "contents" : "#' Predict gender from Brazilian first names\n#'\n#' @description\n#' \\code{get_gender} uses the IBGE's 2010 Census data to predict gender from Brazilian first names.\n#' More specifically, it uses data on the number of females and males with the same name\n#' in Brazil, or in a given Brazilian state, and calculates the proportion of females using it.\n#' The function classifies a name as male or female only when that proportion is higher than\n#' a given threshold (e.g., \\code{female if proportion > 0.9, the default}, or \\code{male if proportion < 0.1});\n#' proportions below this threshold are classified as missing (\\code{NA}). This method is based on the 'gender'\n#' package developed by Muellen (2016). gender: Predict Gender from Names Using Historical Data.\n#'\n#' Multiple names can be passed to the function call. To speed the calculation process,\n#' the package aggregates equal first names to make fewer requests to the IBGE's API. Also, the package contains an internal dataset with all the names reported by the IBGE to make faster classifications -- although this option does not support getting results by State.\n#'\n#' @param names A string specifying a person's first name. Names can also be passed to the function\n#' as a full name (e.g., Ana Maria de Souza). \\code{get_gender} is case insensitive.\n#' @param state A string with the state of federation abbreviation (e.g., \\code{RJ} for Rio de Janeiro). If state is set to a value different from \\code{NULL}, the \\code{internal} argument is ignored.\n#' @param prob Report the proportion of female uses of the name? Defaults to \\code{FALSE}.\n#' @param threshold Numeric indicating the threshold used in predictions. Defaults to 0.9.\n#' @param internal Use internal data to predict gender? Allowing this option makes the function way faster, but it does not support getting results by State. Defaults to \\code{TRUE}.\n#'\n#' @details Information on the Brazilian first names uses by gender was collect in the 2010 Census\n#' (Censo Demografico de 2010, in Portuguese), in July of that year, by the Instituto Brasileiro de Demografia\n#' e Estatistica (IBGE). The surveyed population includes 190,8 million Brazilians living in all 27 states.\n#' According to the IBGE, there are more than 130,000 unique first names in this population.\n#'\n#' @note Names with different spell (e.g., Ana and Anna, or Marcos and Markos) are considered different names.\n#' Additionally, only names with more than 20 occurrences, or more than 15 occurrences in a given state,\n#' are included in the IBGE's data.\n#'\n#' @references For more information on the IBGE's data, please check (in Portuguese):\n#' \\url{http://censo2010.ibge.gov.br/nomes/}\n#'\n#' @seealso \\code{\\link{map_gender}}\n#'\n#' @return \\code{get_gender} may returns three different values: \\code{Female}, if the name provided is female;\n#' \\code{Male}, if the name provided is male; or \\code{NA}, if we can not predict gender from the name given the chosen threshold.\n#'\n#' If the \\code{prob} argument is set to \\code{TRUE}, then the function returns the proportion of females uses of the provided name.\n#'\n#' @examples\n#' # Use get_gender to predict the gender of a person based on her/his first name\n#' get_gender('MARIA DA SILVA SANTOS')\n#' get_gender('joao')\n#'\n#' \\dontrun{\n#' # It is possible to filter results by state\n#' get_gender('ana', state = 'sp')\n#'\n#' # To change the employed threshold\n#' get_gender('ariel', threshold = '0.8')\n#'\n#' # Or to get the proportion of females\n#' # with the name provided\n#' get_gender('iris', prob = TRUE)\n#'\n#' # Multiple names can be predict at the same time\n#' get_gender(c('joao', 'ana', 'benedita', 'rafael'))\n#'\n#' # In different states\n#' get(rep('cris', 3), c('sp', 'am', 'rs'))\n#' }\n#'\n#' @import dplyr\n#' @import httr\n#' @export\n\nget_gender <- function(names, state = NULL, prob = FALSE, threshold = 0.9, internal = TRUE){\n\n\n  # Inputs\n  if(!prob & threshold < 0 | !prob & threshold > 1) stop(\"Threshold must be between 0 and 1.\")\n  if(!is.logical(internal)) stop(\"Internal must be logical.\")\n  if(!is.logical(prob)) stop(\"Prob must be logical.\")\n\n  # Names\n  names <- clean_names(names)\n  un_names <- unique(names)\n  ln_un <- length(un_names)\n  ln <- length(names)\n\n  # Set pauses\n  if(ln > 100) pause <- TRUE\n  else pause <- FALSE\n\n  # Ignore internal when state is declared\n  if(internal & !is.null(state)) internal <- FALSE\n\n\n  ### Internal data\n  if(internal) return(get_gender_internal(names, prob, threshold))\n\n\n  ### API data\n  # Whole country & unique names\n  if(is.null(state) & ln == ln_un){\n\n    # Return\n    out <- sapply(1:ln, function(i) get_gender_api(names[i], state, prob = prob, threshold = threshold, pause = pause))\n    return(out)\n  }\n\n  # Whole country & non-unique names\n  if(is.null(state)) {\n\n    # Pick unique names\n    gender_pred <- sapply(1:ln_un, function(i) get_gender_api(un_names[i], state, prob = prob, threshold = threshold, pause = pause))\n\n    # Join\n    names <- dplyr::tibble(names = names)\n    un_names <- dplyr::tibble(names = un_names, prob = gender_pred)\n\n    # Return\n    out <- dplyr::left_join(names, un_names, by = c(\"names\"))$prob\n    return(out)\n  }\n\n  # By state & unique names\n  if(ln == ln_un){\n\n    # Return\n    state <- get_state(state, ln)\n    out <- sapply(1:ln, function(i) get_gender_api(names[i], state[i], prob = prob, threshold = threshold, pause = pause))\n    return(out)\n  }\n\n  # By state & non-unique names\n  state <- get_state(state, ln)\n  names <- dplyr::tibble(names = names, state = state)\n  dis_names <- dplyr::distinct(names)\n\n  dis_names$prob <- sapply(1:length(dis_names$names), function(i) get_gender_api(dis_names$names[i], dis_names$state[i], prob = prob, threshold = threshold, pause = pause))\n  out <- dplyr::left_join(names, dis_names, by = c(\"names\", \"state\"))$prob\n\n  return(out)\n}\n\n\n# Get individual results from API\nget_gender_api <- function(name, state, prob, threshold, pause = pause){\n\n\n  # API endpoint\n  ibge <- \"http://servicodados.ibge.gov.br/api/v1/censos/nomes/basica\"\n\n  # GET\n  females <- httr::GET(ibge, query = list(nome = name, regiao = state, sexo = \"f\"))\n  if(pause) Sys.sleep(0.3)\n  males <- httr::GET(ibge, query = list(nome = name, regiao = state, sexo = \"m\"))\n\n  # Test responses\n  res <- test_responses(females, males, prob)\n  if(!is.null(res)) return(res)\n\n  # Parse freq\n  females <- httr::content(females, as = \"parsed\")[[1]]$freq\n  males <- httr::content(males, as = \"parsed\")[[1]]$freq\n\n  # Return\n  fprob <- females / sum(females, males)\n  if(prob) return(fprob)\n  round_guess(fprob, threshold)\n}\n\n\n\n# Get results from internal data\nget_gender_internal <- function(names, prob, threshold){\n\n  # Join data\n  nms <- dplyr::tibble(nome = names) %>%\n    dplyr::left_join(nomes, by = \"nome\")\n\n  # Return\n  if(prob) return(nms$prob_fem)\n  round_guess(nms$prob_fem, threshold)\n}\n\n",
    "created" : 1523974797672.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "554967666",
    "id" : "8F8BEC4",
    "lastKnownWriteTime" : 1523977748,
    "last_content_update" : 1523977748686,
    "path" : "C:/Users/User/Google Drive/R/Pacotes/genderBR/R/get_gender.R",
    "project_path" : "R/get_gender.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}